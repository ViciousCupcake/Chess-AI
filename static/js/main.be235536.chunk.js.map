{"version":3,"sources":["components/square.js","components/board.js","pieces/piece.js","helpers/index.js","pieces/king.js","components/fallen-soldier-block.js","pieces/bishop.js","pieces/knight.js","pieces/pawn.js","pieces/queen.js","pieces/rook.js","helpers/board-initialiser.js","helpers/invalidDepthException.js","helpers/minimax.js","components/game.js","index.js"],"names":["Square","props","className","shade","tint","onClick","style","keyVal","Board","i","squareShade","possibleMoveTint","this","squares","board","squareRows","j","isEven","push","renderSquare","isPossibleMove","React","Component","num","Piece","player","iconUrl","value","backgroundImage","diagonalDictionaryTLBR","require","diagonalDictionaryTRBL","rowDictionary","columnDictionary","isSameRow","src","dest","isSameColumn","isSameDiagonal","isPathClean","srcToDestPath","Map","reduce","acc","curr","get","isValidIndex","index","toChessLocation","row","Math","floor","col","String","fromCharCode","King","possibleMoves","forEach","currentDiff","isMovePossible","FallenSoldierBlock","square","piece","whiteFallenSoldiers","map","ws","blackFallenSoldiers","bs","Bishop","isDestEnemyOccupied","Boolean","getSrcToDestPath","Object","keys","current","Number","pathStart","pathEnd","incrementBy","path","abs","Knight","possibleDifferences","total","isBetweenLeftRightBoundary","rowColDiffTable","destRow","destCol","srcRow","srcCol","Pawn","initialPositions","1","2","undefined","isDestinationOK","indexOf","Queen","Rook","initialiseChessBoard","Array","fill","getInitialSoldierIndices","output","Set","add","InvalidDepthException","message","Error","captureStackTrace","stack","prototype","create","name","constructor","computationsPerformed","minimaxRunner","whiteAliveSoldiers","blackAliveSoldiers","depth","self","mapObj","obj","set","isMaximizingPlayer","bestMove","bestDest","bestSrc","alpha","beta","initialAliveSoldiers","lostPiece","lostPieceObj","score","outerMaximizingLoop","getPossibleMoves","has","delete","minimax","pop","max","outerMinimizingLoop","min","console","log","setState","oldState","computations","handleClick","sum","element","getValue","evaluateScore","Game","state","sourceSelection","status","turn","isGameOver","backgroundColor","charAt","toUpperCase","slice","setTimeout","getPlayer","opponent","playersKingPosition","getKingPosition","idx","id","href","target","rel","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.be235536.chunk.js","sourcesContent":["import React from 'react';\n\nimport '../index.css';\n\nexport default function Square(props) {\n\n  return (\n    <button className={\"square \" + props.shade + \" \" + props.tint}\n      onClick={props.onClick}\n      style={props.style}\n      key={props.keyVal}\n    >\n\n    </button>\n  );\n\n}\n","import React from 'react';\n\nimport '../index.css';\nimport Square from './square.js';\n\nexport default class Board extends React.Component {\n\n  renderSquare(i, squareShade, possibleMoveTint) {\n    return <Square\n      key={i}\n      keyVal={i}\n      style={this.props.squares[i] ? this.props.squares[i].style : null}\n      shade={squareShade}\n      tint={possibleMoveTint}\n      onClick={() => this.props.onClick(i)}\n    />\n  }\n\n  render() {\n    const board = [];\n    for (let i = 0; i < 8; i++) {\n      const squareRows = [];\n      for (let j = 0; j < 8; j++) {\n        const squareShade = (isEven(i) && isEven(j)) || (!isEven(i) && !isEven(j)) ? \"light-square\" : \"dark-square\";\n        squareRows.push(this.renderSquare((i * 8) + j, squareShade, this.props.isPossibleMove[(i * 8) + j] ? \"possible-move\" : \"\"));\n      }\n      board.push(<div className=\"board-row\" key={i}>{squareRows}</div>)\n    }\n\n    return (\n      <div>\n        {board}\n      </div>\n    );\n  }\n}\n\n\nfunction isEven(num) {\n  return num % 2 === 0\n}","export default class Piece {\n  constructor(player, iconUrl, value) {\n    this.player = player;\n    this.style = { backgroundImage: \"url('\" + iconUrl + \"')\" };\n    this.value = value;\n  }\n\n  getPlayer() {\n    return this.player\n  }\n}","const diagonalDictionaryTLBR = require('../dictionaries/diagonalTopLeftBottomRight.json');\nconst diagonalDictionaryTRBL = require('../dictionaries/diagonalTopRightBottomLeft.json');\nconst rowDictionary = require('../dictionaries/row.json');\nconst columnDictionary = require('../dictionaries/column.json');\n\n/**\n * Calculates if two indices are on the same row\n * @param {Number} src - An index from 0..63\n * @param {*} dest - An index from 0..63\n * @returns {boolean} Returns true if the two indices are on the same row\n */\nexport const isSameRow = (src, dest) => { // TODO: Make more efficient using math\n  return !!(rowDictionary[src] && rowDictionary[src][dest]);\n}\n\n/**\n * Calculates if two indices are on the same column\n * @param {Number} src - An index from 0..63\n * @param {*} dest - An index from 0..63\n * @returns {boolean} Returns true if the two indices are on the same column\n */\nexport const isSameColumn = (src, dest) => {\n  return !!(columnDictionary[src] && columnDictionary[src][dest]);\n}\n\n/**\n * Calculates if two indices are on the same diagonal\n * @param {Number} src - An index from 0..63\n * @param {*} dest - An index from 0..63\n * @returns {boolean} Returns true if the two indices are on the same diagonal\n */\nexport const isSameDiagonal = (src, dest) => {\n  return !!((diagonalDictionaryTLBR[src] && diagonalDictionaryTLBR[src][dest]) ||\n    (diagonalDictionaryTRBL[src] && diagonalDictionaryTRBL[src][dest]))\n}\n\n/**\n * Calculates if a given path has no pieces on it\n * @param {Number[]} srcToDestPath - The path to be checked\n * @param {Piece[]|Map<Number, Piece>} squares - The array/map that represents the locations of all pieces on the board\n * @returns {boolean} returns true if there are no pieces on the given path, and vice versa.\n */\nexport const isPathClean = (srcToDestPath, squares) => {\n  var out = undefined;\n  if (squares instanceof Map) {\n    out = srcToDestPath.reduce((acc, curr) => { return !squares.get(curr) && acc; }, true);\n  }\n  else {\n    out = srcToDestPath.reduce((acc, curr) => { return !squares[curr] && acc; }, true);\n  }\n  return out;\n}\n\n/**\n * Calculates if a index is calid\n * @param {Number} index - The index\n * @returns {boolean} If the index is valid or not\n */\nexport const isValidIndex = (index) => {\n  return index >= 0 && index <= 63;\n}\n\n/**\n * Compares two maps for equality\n * @param {Map} map1 - One map to be compared\n * @param {Map} map2 - The second map to be compared\n * @returns {boolean} returns true if both maps are equal\n */\nexport const compareMaps = (map1, map2) => {\n  var testVal;\n  if (map1.size !== map2.size) {\n    console.log(map1);\n    console.log(map2);\n    console.log(\"maps not equal\");\n\n    return false;\n  }\n  for (var [key, val] of map1) {\n    testVal = map2.get(key);\n    // in cases of an undefined value, make sure the key\n    // actually exists on the object so there are no false positives\n    if (testVal !== val || (testVal === undefined && !map2.has(key))) {\n      console.log(map1);\n      console.log(map2);\n      console.log(\"maps not equal\");\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests if the map contains all keys from two sets.\n * @param {Map} map1 - The map to test\n * @param {Set} set1 - One set to test\n * @param {Set} set2 - The other set to test\n * @returns {boolean} returns true if the map has only keys that are found within set1 and set2\n */\nexport const compareMapsAndSets = (map1, set1, set2) => {\n  if (map1.size !== (set1.size + set2.size)) {\n    console.log(\"Differing sizes\");\n    console.log(map1);\n    console.log(set1);\n    console.log(set2);\n    return false;\n  }\n  for (var [key, val] of map1) {\n    // in cases of an undefined value, make sure the key\n    // actually exists on the object so there are no false positives\n    if (!(set1.has(key) || set2.has(key))) {\n      console.log(\"Key not found\");\n      console.log(map1);\n      console.log(set1);\n      console.log(set2);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Converts an index to a chess location\n * @param {Number} index - The index to convert 0..63\n * @returns {string} The corresponding location on the board\n */\nexport const toChessLocation = (index) => {\n  var row = 8 - Math.floor(index / 8);\n  var col = index % 8;\n  return String.fromCharCode(65 + col) + row;\n}","import Piece from './piece.js';\nimport { isSameDiagonal, isSameRow, isValidIndex } from '../helpers/index.js'\n\nexport default class King extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg\"),\n      50);\n  }\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    if (squares instanceof Map) {\n      return isValidIndex(dest) && // destination is valid index\n        (!squares.get(dest) ||  // destination is null or\n          squares.get(dest).player !== this.player) && // destination is occupied by an enemy\n        ((src - 9 === dest && isSameDiagonal(src, dest)) ||\n          src - 8 === dest ||\n          (src - 7 === dest && isSameDiagonal(src, dest)) ||\n          (src + 1 === dest && isSameRow(src, dest)) ||\n          (src + 9 === dest && isSameDiagonal(src, dest)) ||\n          src + 8 === dest ||\n          (src + 7 === dest && isSameDiagonal(src, dest)) ||\n          (src - 1 === dest && isSameRow(src, dest)));\n    }\n    else {\n      return isValidIndex(dest) && // destination is valid index\n        (!squares[dest] ||  // destination is null or\n          squares[dest].player !== this.player) && // destination is occupied by an enemy\n        ((src - 9 === dest && isSameDiagonal(src, dest)) ||\n          src - 8 === dest ||\n          (src - 7 === dest && isSameDiagonal(src, dest)) ||\n          (src + 1 === dest && isSameRow(src, dest)) ||\n          (src + 9 === dest && isSameDiagonal(src, dest)) ||\n          src + 8 === dest ||\n          (src + 7 === dest && isSameDiagonal(src, dest)) ||\n          (src - 1 === dest && isSameRow(src, dest)));\n    }\n  }\n\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    const possibleDifferences = [-9, -8, -7, 1, 9, 8, 7, -1];\n    possibleDifferences.forEach((currentDiff) => {\n      if (isValidIndex(src + currentDiff) && this.isMovePossible(src, src + currentDiff, squares)) {\n        possibleMoves.push(src + currentDiff);\n      }\n    });\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath(src, dest) {\n    return []; // The king can travel at most 1 space so it won't hop over any pieces\n  }\n}\n","import React from 'react';\n\nimport '../index.css';\nimport Square from './square.js';\n\nexport default class FallenSoldierBlock extends React.Component {\n\n  renderSquare(square, i, squareShade) {\n    return <Square\n      key={i}\n      keyVal={i}\n      piece={square}\n      style={square.style}\n    />\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row indiv-fallen-block\">{this.props.whiteFallenSoldiers.map((ws, index) =>\n          this.renderSquare(ws, index)\n        )}</div>\n        <div className=\"board-row indiv-fallen-block\">{this.props.blackFallenSoldiers.map((bs, index) =>\n          this.renderSquare(bs, index)\n        )}</div>\n      </div>\n    );\n  }\n}\n\n","import Piece from './piece.js';\nimport { isSameDiagonal, isPathClean } from '../helpers/index.js'\n\nexport default class Bishop extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg\"),\n      3);\n  }\n\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    if (squares instanceof Map) {\n      const isDestEnemyOccupied = Boolean(squares.get(dest)) && squares.get(dest).player !== this.player;\n      return src !== dest && isPathClean(this.getSrcToDestPath(src, dest), squares) && isSameDiagonal(src, dest) && (!squares.get(dest) || isDestEnemyOccupied);\n    }\n    else {\n      const isDestEnemyOccupied = Boolean(squares[dest]) && squares[dest].player !== this.player;\n      return src !== dest && isPathClean(this.getSrcToDestPath(src, dest), squares) && isSameDiagonal(src, dest) && (!squares[dest] || isDestEnemyOccupied);\n    }\n\n  }\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    const diagonalDictionaryTLBR = require('../dictionaries/diagonalTopLeftBottomRight.json');\n    const diagonalDictionaryTRBL = require('../dictionaries/diagonalTopRightBottomLeft.json');\n    if (!!diagonalDictionaryTLBR[src]) {\n      Object.keys(diagonalDictionaryTLBR[src]).forEach((current) => {\n        current = Number(current);\n        if (this.isMovePossible(src, current, squares)) {\n          possibleMoves.push(current);\n        }\n      });\n    }\n    if (!!diagonalDictionaryTRBL[src]) {\n      Object.keys(diagonalDictionaryTRBL[src]).forEach((current) => {\n        current = Number(current);\n        if (this.isMovePossible(src, current, squares)) {\n          possibleMoves.push(current);\n        }\n      });\n    }\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath(src, dest) {\n    let path = [], pathStart, pathEnd, incrementBy;\n    if (src > dest) {\n      pathStart = dest;\n      pathEnd = src;\n    }\n    else {\n      pathStart = src;\n      pathEnd = dest;\n    }\n    if (Math.abs(src - dest) % 9 === 0) {\n      incrementBy = 9;\n      pathStart += 9;\n    }\n    else {\n      incrementBy = 7;\n      pathStart += 7;\n    }\n\n    for (let i = pathStart; i < pathEnd; i += incrementBy) {\n      path.push(i);\n    }\n    return path;\n  }\n}\n","import Piece from './piece.js';\nimport { isSameRow, isValidIndex } from '../helpers/index.js'\n\nexport default class Knight extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg\"),\n      3);\n  }\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    const possibleDifferences = [-17, -10, 6, 15, -15, -6, 10, 17];\n    if (squares instanceof Map) {\n      return possibleDifferences.reduce((total, currentDiff) => {\n        return total ||\n          (src + currentDiff === dest &&\n            !isSameRow(src, dest) &&\n            this.isBetweenLeftRightBoundary(src, dest) &&\n            (!squares.get(dest) /* not null*/ || squares.get(src).player !== squares.get(dest).player));\n      }, false);\n    }\n    else {\n      return possibleDifferences.reduce((total, currentDiff) => {\n        return total ||\n          (src + currentDiff === dest &&\n            !isSameRow(src, dest) &&\n            this.isBetweenLeftRightBoundary(src, dest) &&\n            (!squares[dest] /* not null*/ || squares[src].player !== squares[dest].player));\n      }, false);\n    }\n  }\n\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    const possibleDifferences = [-17, -10, 6, 15, -15, -6, 10, 17];\n    possibleDifferences.forEach((currentDiff) => {\n      if (isValidIndex(src + currentDiff) && this.isMovePossible(src, src + currentDiff, squares)) {\n        possibleMoves.push(src + currentDiff);\n      }\n    });\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * returns true if knight doesn't pass through the left or right boundary (i.e. knight doesnt jump from the left side to the right side)\n   * @param {number} src - Initial position\n   * @param {number} dest - Ending position\n   */\n  isBetweenLeftRightBoundary(src, dest) {\n    const rowColDiffTable = require('../dictionaries/knightMapping.json');\n    var destRow = Math.floor(dest / 8); // Integer division\n    var destCol = dest % 8;\n    var srcRow = Math.floor(src / 8);\n    var srcCol = src % 8;\n\n    return (rowColDiffTable[dest - src] && rowColDiffTable[dest - src]['row'] === (destRow - srcRow) && rowColDiffTable[dest - src]['col'] === (destCol - srcCol));\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath() {\n    return [];\n  }\n}\n","import Piece from './piece.js';\nimport { isSameDiagonal, isValidIndex, isPathClean } from '../helpers/index.js'\n\nexport default class Pawn extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg\"),\n      1);\n    this.initialPositions = {\n      1: [48, 49, 50, 51, 52, 53, 54, 55],\n      2: [8, 9, 10, 11, 12, 13, 14, 15]\n    }\n  }\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    var isDestEnemyOccupied = undefined;\n    var isDestinationOK = undefined;\n    if (squares instanceof Map) {\n      isDestEnemyOccupied = Boolean(squares.get(dest)) && squares.get(dest).player !== this.player;\n      isDestinationOK = isPathClean(this.getSrcToDestPath(src, dest), squares) && (!squares.get(dest) || isDestEnemyOccupied);\n    }\n    else {\n      isDestEnemyOccupied = Boolean(squares[dest]) && squares[dest].player !== this.player;\n      isDestinationOK = isPathClean(this.getSrcToDestPath(src, dest), squares) && (!squares[dest] || isDestEnemyOccupied);\n    }\n\n    if (this.player === 1) {\n      if ((dest === src - 8 && !isDestEnemyOccupied) || (dest === src - 16 && !isDestEnemyOccupied && this.initialPositions[1].indexOf(src) !== -1)) {\n        return isDestinationOK;\n      }\n      else if (isDestEnemyOccupied && isSameDiagonal(src, dest) && (dest === src - 9 || dest === src - 7)) {\n        return isDestinationOK;\n      }\n    }\n    else if (this.player === 2) {\n      if ((dest === src + 8 && !isDestEnemyOccupied) || (dest === src + 16 && !isDestEnemyOccupied && this.initialPositions[2].indexOf(src) !== -1)) {\n        return isDestinationOK;\n      }\n      else if (isDestEnemyOccupied && isSameDiagonal(src, dest) && (dest === src + 9 || dest === src + 7)) {\n        return isDestinationOK;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    const possibleDifferences = {\n      1: [-8, -16, -9, -7],\n      2: [8, 16, 9, 7]\n    }\n    possibleDifferences[this.player].forEach((currentDiff) => {\n      if (isValidIndex(src + currentDiff) && this.isMovePossible(src, src + currentDiff, squares)) {\n        possibleMoves.push(src + currentDiff);\n      }\n    });\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath(src, dest) {\n    if (dest === src - 16) {\n      return [src - 8];\n    }\n    else if (dest === src + 16) {\n      return [src + 8];\n    }\n    return [];\n  }\n}\n","import Piece from './piece.js';\nimport { isSameRow, isSameColumn, isSameDiagonal, isPathClean, isValidIndex } from '../helpers/index.js'\n\nexport default class Queen extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg\"),\n      9);\n  }\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    if (squares instanceof Map) {\n      const isDestEnemyOccupied = Boolean(squares.get(dest)) && squares.get(dest).player !== this.player;\n      return src !== dest && (!squares.get(dest) || isDestEnemyOccupied) && isPathClean(this.getSrcToDestPath(src, dest), squares) && (isSameDiagonal(src, dest) || isSameRow(src, dest) || isSameColumn(src, dest));\n    }\n    else {\n      const isDestEnemyOccupied = Boolean(squares[dest]) && squares[dest].player !== this.player;\n      return src !== dest && (!squares[dest] || isDestEnemyOccupied) && isPathClean(this.getSrcToDestPath(src, dest), squares) && (isSameDiagonal(src, dest) || isSameRow(src, dest) || isSameColumn(src, dest));\n    }\n\n  }\n\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    var dest = 1000;\n    // column\n    for (dest = src % 8; isValidIndex(dest); dest += 8) {\n      if (this.isMovePossible(src, dest, squares)) {\n        possibleMoves.push(dest);\n      }\n    }\n\n    // row\n    for (dest = Math.floor(src / 8) * 8; dest < (Math.floor(src / 8) * 8 + 8); dest++) {\n      if (this.isMovePossible(src, dest, squares)) {\n        possibleMoves.push(dest);\n      }\n    }\n\n    // diagonal\n    const diagonalDictionaryTLBR = require('../dictionaries/diagonalTopLeftBottomRight.json');\n    const diagonalDictionaryTRBL = require('../dictionaries/diagonalTopRightBottomLeft.json');\n    if (!!diagonalDictionaryTLBR[src]) {\n      Object.keys(diagonalDictionaryTLBR[src]).forEach((current) => {\n        current = Number(current);\n        if (this.isMovePossible(src, current, squares)) {\n          possibleMoves.push(current);\n        }\n      });\n    }\n    if (!!diagonalDictionaryTRBL[src]) {\n      Object.keys(diagonalDictionaryTRBL[src]).forEach((current) => {\n        current = Number(current);\n        if (this.isMovePossible(src, current, squares)) {\n          possibleMoves.push(current);\n        }\n      });\n    }\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath(src, dest) {\n    let path = [], pathStart, pathEnd, incrementBy;\n    if (src > dest) {\n      pathStart = dest;\n      pathEnd = src;\n    }\n    else {\n      pathStart = src;\n      pathEnd = dest;\n    }\n    if (Math.abs(src - dest) % 8 === 0 && isSameColumn(src, dest)) {\n      incrementBy = 8;\n      pathStart += 8;\n    }\n    else if (Math.abs(src - dest) % 9 === 0 && isSameDiagonal(src, dest)) {\n      incrementBy = 9;\n      pathStart += 9;\n    }\n    else if (Math.abs(src - dest) % 7 === 0 && isSameDiagonal(src, dest)) {\n      incrementBy = 7;\n      pathStart += 7;\n    }\n    else {\n      incrementBy = 1;\n      pathStart += 1;\n    }\n\n    for (let i = pathStart; i < pathEnd; i += incrementBy) {\n      path.push(i);\n    }\n    return path;\n  }\n}","import Piece from './piece.js';\nimport { isSameRow, isSameColumn, isPathClean, isValidIndex } from '../helpers/index.js'\n\nexport default class Rook extends Piece {\n  constructor(player) {\n    super(player,\n      (player === 1 ? \"https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg\" : \"https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg\"),\n      5);\n  }\n  /**\n   * returns true if a move is possible\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {number} dest - ending position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Boolean} if a move is possible\n   */\n  isMovePossible(src, dest, squares) {\n    if (squares instanceof Map) {\n      const isDestEnemyOccupied = Boolean(squares.get(dest)) && squares.get(dest).player !== this.player;\n      return src !== dest && (!squares.get(dest) || isDestEnemyOccupied) && isPathClean(this.getSrcToDestPath(src, dest), squares) && (isSameColumn(src, dest) || isSameRow(src, dest));\n    }\n    else {\n      const isDestEnemyOccupied = Boolean(squares[dest]) && squares[dest].player !== this.player;\n      return src !== dest && (!squares[dest] || isDestEnemyOccupied) && isPathClean(this.getSrcToDestPath(src, dest), squares) && (isSameColumn(src, dest) || isSameRow(src, dest));\n    }\n  }\n\n  /**\n   * Generates an array representing the indices that the piece can move to\n   * @param {number} src - starting position, represented as an index from 0..63\n   * @param {Piece[]|Map} squares - array or map representing locations of chess pieces\n   * @returns {Number[]} An array representing the indices that the piece can move to\n   */\n  getPossibleMoves(src, squares) {\n    const possibleMoves = [];\n    // column\n    // TODO: Optimize by using while loop starting from src and going outwards until reaching a piece\n    var dest = 1000;\n    for (dest = src % 8; isValidIndex(dest); dest += 8) {\n      if (this.isMovePossible(src, dest, squares)) {\n        possibleMoves.push(dest);\n      }\n    }\n\n    // row\n    for (dest = Math.floor(src / 8) * 8; dest < (Math.floor(src / 8) * 8 + 8); dest++) {\n      if (this.isMovePossible(src, dest, squares)) {\n        possibleMoves.push(dest);\n      }\n    }\n    return possibleMoves;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  /**\n   * Generate an array of the indices that the piece will travel through between src and dest (src and dest exclusive)\n   * @param  {number} src - starting position, represented as an index from 0..63\n   * @param  {number} src - ending position, represented as an index from 0..63\n   * @return {number[]} The indicies that the piece will travel through\n   */\n  getSrcToDestPath(src, dest) {\n    let path = [], pathStart, pathEnd, incrementBy;\n    if (src > dest) {\n      pathStart = dest;\n      pathEnd = src;\n    }\n    else {\n      pathStart = src;\n      pathEnd = dest;\n    }\n    if (Math.abs(src - dest) % 8 === 0 && isSameColumn(src, dest)) {\n      incrementBy = 8;\n      pathStart += 8;\n    }\n    else {\n      incrementBy = 1;\n      pathStart += 1;\n    }\n\n    for (let i = pathStart; i < pathEnd; i += incrementBy) {\n      path.push(i);\n    }\n    return path;\n  }\n}\n","import Bishop from '../pieces/bishop.js';\nimport King from '../pieces/king.js';\nimport Knight from '../pieces/knight.js';\nimport Pawn from '../pieces/pawn.js';\nimport Queen from '../pieces/queen.js';\nimport Rook from '../pieces/rook.js';\n\n/**\n * Initializes the board and places the chess pieces where they belong\n * @returns {Piece[]} An array representing the pieces that were generated\n */\nexport const initialiseChessBoard = () => {\n  const squares = Array(64).fill(null);\n\n  for (let i = 8; i < 16; i++) {\n    squares[i] = new Pawn(2);\n    squares[i + 40] = new Pawn(1);\n  }\n  squares[0] = new Rook(2);\n  squares[7] = new Rook(2);\n  squares[56] = new Rook(1);\n  squares[63] = new Rook(1);\n\n  squares[1] = new Knight(2);\n  squares[6] = new Knight(2);\n  squares[57] = new Knight(1);\n  squares[62] = new Knight(1);\n\n  squares[2] = new Bishop(2);\n  squares[5] = new Bishop(2);\n  squares[58] = new Bishop(1);\n  squares[61] = new Bishop(1);\n\n  squares[3] = new Queen(2);\n  squares[4] = new King(2);\n\n  squares[59] = new Queen(1);\n  squares[60] = new King(1);\n\n  return squares;\n}\n\n/**\n * Generates an Set representing the initial locations of pieces for a given player \n * @param {Number} player - A number representing the piece to get the initial soldier indices (1 -> white, 2 -> black)\n * @returns {Set<Number>} The initial locations of the pieces for a given player\n */\nexport const getInitialSoldierIndices = (player) => {\n  const output = new Set();\n  var index = 1000;\n  if(player === 2){\n    for(index = 0; index < 16; index++){\n      output.add(index);\n    }\n  }\n  else if(player === 1){\n    for(index = 48; index < 64; index++){\n      output.add(index);\n    }\n  }\n  return output;\n}","/**\n * The exception that gets thrown if an invalid depth was specified in the minimax function\n */\nexport default function InvalidDepthException() {\n    this.message = \"Invalid Depth was Provided! Depth must be >= 1\";\n    // Use V8's native method if available, otherwise fallback\n    if (\"captureStackTrace\" in Error)\n        Error.captureStackTrace(this, InvalidDepthException);\n    else\n        this.stack = (new Error()).stack;\n}\n\nInvalidDepthException.prototype = Object.create(Error.prototype);\nInvalidDepthException.prototype.name = \"InvalidDepthException\";\nInvalidDepthException.prototype.constructor = InvalidDepthException;","import Piece from \"../pieces/piece\";\nimport InvalidDepthException from \"./invalidDepthException\";\nimport { toChessLocation } from \"./index\"\nvar computationsPerformed = 0;\n\n/**\n * Calculates the best move and plays it\n * @param {Piece[]} squares - Array representing the Pieces on the board\n * @param {Set<Number>} whiteAliveSoldiers - Set of the indices of all alive white soldiers\n * @param {Set<Number>} blackAliveSoldiers - Set of the indices of all alive black soldiers\n * @param {Piece[]} whiteFallenSoldiers - Set of the indices of all fallen white soldiers\n * @param {Piece[]} blackFallenSoldiers - Set of the indices of all fallen black soldiers\n * @param {Number} depth - Depth of recursive call to calculate best moves from\n * @param {Number} player - Which player to move (1 or 2)\n * @param {Object} self - A pointer to the object that called this function (i.e. this)\n * @throws Exception if depth < 1\n */\nexport default function minimaxRunner(squares, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth, player, self) {\n    if (depth < 1) {\n        throw new InvalidDepthException();\n    }\n    // convert squares to a map for better access\n    var map = squares.reduce((mapObj, obj, index) => {\n        if (obj != null) {\n            mapObj.set(index, obj);\n        }\n        return mapObj;\n    }, new Map());\n\n    const isMaximizingPlayer = player === 1 ? true : false;\n    var bestMove = isMaximizingPlayer ? -9999 : 9999;\n    var bestDest = 1000;\n    var bestSrc = 1000;\n    var alpha = -10000;\n    var beta = 10000;\n    var initialAliveSoldiers = undefined;\n    var src = undefined;\n    var dest = undefined;\n    var lostPiece = undefined;\n    var lostPieceObj = undefined;\n    var score = undefined;\n    if (isMaximizingPlayer) {\n        initialAliveSoldiers = new Set(whiteAliveSoldiers);\n        outerMaximizingLoop:\n        for (src of initialAliveSoldiers) {\n            for (dest of map.get(src).getPossibleMoves(src, map)) {\n                computationsPerformed++;\n                lostPiece = undefined;\n                lostPieceObj = undefined;\n\n                // If destination results in opposite side losing a piece\n                if (blackAliveSoldiers.has(dest)) {\n                    blackAliveSoldiers.delete(dest);\n                    blackFallenSoldiers.push(map.get(dest));\n                    lostPieceObj = map.get(dest);\n                    map.delete(dest);\n                    lostPiece = dest;\n                }\n                whiteAliveSoldiers.delete(src);\n                whiteAliveSoldiers.add(dest);\n                map.set(dest, map.get(src));\n                map.delete(src);\n                score = minimax(map, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth - 1, 2, alpha, beta, squares);\n                // Undo the previous move (better to undo than make copies of arrays, undo is better big-O)\n                map.set(src, map.get(dest));\n                map.delete(dest);\n                whiteAliveSoldiers.delete(dest);\n                whiteAliveSoldiers.add(src);\n                if (lostPiece !== undefined) {\n                    blackAliveSoldiers.add(lostPiece);\n                    blackFallenSoldiers.pop();\n                    map.set(dest, lostPieceObj);\n                }\n                if (score > bestMove) {\n                    bestMove = score;\n                    bestDest = dest;\n                    bestSrc = src;\n                }\n\n\n                alpha = Math.max(alpha, bestMove);\n                if (alpha >= beta) {\n                    break outerMaximizingLoop;\n                }\n            }\n        }\n    }\n    else { // black's turn\n        initialAliveSoldiers = new Set(blackAliveSoldiers);\n        outerMinimizingLoop:\n        for (src of initialAliveSoldiers) {\n            for (dest of map.get(src).getPossibleMoves(src, map)) {\n                computationsPerformed++;\n                lostPiece = undefined;\n                lostPieceObj = undefined;\n                // If destination results in opposite side losing a piece\n                if (whiteAliveSoldiers.has(dest)) {\n                    whiteAliveSoldiers.delete(dest);\n                    whiteFallenSoldiers.push(map.get(dest));\n                    lostPieceObj = map.get(dest);\n                    map.delete(dest);\n                    lostPiece = dest;\n                }\n                blackAliveSoldiers.delete(src);\n                blackAliveSoldiers.add(dest);\n                map.set(dest, map.get(src));\n                map.delete(src);\n                score = minimax(map, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth - 1, 1, alpha, beta, squares);\n                // Undo the previous move (better to undo than make copies of arrays, undo is better big-O)\n                map.set(src, map.get(dest));\n                map.delete(dest);\n                blackAliveSoldiers.delete(dest);\n                blackAliveSoldiers.add(src);\n                if (lostPiece !== undefined) {\n                    whiteAliveSoldiers.add(lostPiece);\n                    whiteFallenSoldiers.pop();\n                    map.set(dest, lostPieceObj);\n                }\n                if (score < bestMove) {\n                    bestMove = score;\n                    bestDest = dest;\n                    bestSrc = src;\n                }\n\n                beta = Math.min(beta, bestMove);\n                if (beta <= alpha) {\n                    break outerMinimizingLoop;\n                }\n            }\n        }\n    }\n    console.log(\"Score: \" + bestMove);\n    console.log(\"Best Source: \" + bestSrc);\n    console.log(\"Best Destination: \" + bestDest);\n    console.log(\"Repetitions: \" + computationsPerformed);\n\n    self.setState(oldState => ({\n        score: bestMove,\n        bestSrc: toChessLocation(bestSrc),\n        bestDest: toChessLocation(bestDest),\n        computations: computationsPerformed\n    }));\n    self.handleClick(bestSrc);\n    self.handleClick(bestDest);\n    computationsPerformed = 0;\n}\n\n/**\n * Internal Function that does Minimax AB\n * @param {Map<Number, Piece>} map - Map representing locations of pieces on the board\n * @param {Set<Number>} whiteAliveSoldiers - Set of the indices of all alive white soldiers\n * @param {Set<Number>} blackAliveSoldiers - Set of the indices of all alive black soldiers\n * @param {Piece[]} whiteFallenSoldiers - Set of the indices of all fallen white soldiers\n * @param {Piece[]} blackFallenSoldiers - Set of the indices of all fallen black soldiers\n * @param {Number} depth - Depth of recursive call to calculate best moves from\n * @param {Number} player - Which player to move (1 or 2)\n * @param {Number} alpha - Alpha value\n * @param {Number} beta - Beta value\n * @param {Piece[]} squares - Array representing the Pieces on the board\n */\nfunction minimax(map, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth, player, alpha, beta, squares) {\n    if (depth < 1) {\n        return evaluateScore(map, whiteAliveSoldiers, blackAliveSoldiers);\n    }\n\n    const isMaximizingPlayer = player === 1 ? true : false;\n    var bestMove = isMaximizingPlayer ? -9999 : 9999;\n    var initialAliveSoldiers = undefined;\n    var src = undefined;\n    var dest = undefined;\n    var lostPiece = undefined;\n    var lostPieceObj = undefined;\n    var score = undefined;\n    if (isMaximizingPlayer) {\n        initialAliveSoldiers = new Set(whiteAliveSoldiers);\n        outerMaximizingLoop:\n        for (src of initialAliveSoldiers) {\n            for (dest of map.get(src).getPossibleMoves(src, map)) {\n                computationsPerformed++;\n                lostPiece = undefined;\n                lostPieceObj = undefined;\n                // If destination results in opposite side losing a piece\n                if (blackAliveSoldiers.has(dest)) {\n                    blackAliveSoldiers.delete(dest);\n                    blackFallenSoldiers.push(map.get(dest));\n                    lostPieceObj = map.get(dest);\n                    map.delete(dest);\n                    lostPiece = dest;\n                }\n                whiteAliveSoldiers.delete(src);\n                whiteAliveSoldiers.add(dest);\n                map.set(dest, map.get(src));\n                map.delete(src);\n                score = minimax(map, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth - 1, 2, alpha, beta, squares);\n                // Undo the previous move (better to undo than make copies of arrays, undo is better big-O)\n                map.set(src, map.get(dest));\n                map.delete(dest);\n                whiteAliveSoldiers.delete(dest);\n                whiteAliveSoldiers.add(src);\n                if (lostPiece !== undefined) {\n                    blackAliveSoldiers.add(lostPiece);\n                    blackFallenSoldiers.pop();\n                    map.set(dest, lostPieceObj);\n                }\n                if (score > bestMove) {\n                    bestMove = score;\n                }\n                alpha = Math.max(alpha, bestMove);\n                if (alpha >= beta) {\n                    break outerMaximizingLoop;\n                }\n            }\n        }\n    }\n    else { // black's turn\n        initialAliveSoldiers = new Set(blackAliveSoldiers);\n        outerMinimizingLoop:\n        for (src of initialAliveSoldiers) {\n            for (dest of map.get(src).getPossibleMoves(src, map)) {\n                computationsPerformed++;\n                lostPiece = undefined;\n                lostPieceObj = undefined;\n                // If destination results in opposite side losing a piece\n                if (whiteAliveSoldiers.has(dest)) {\n                    whiteAliveSoldiers.delete(dest);\n                    whiteFallenSoldiers.push(map.get(dest));\n                    lostPieceObj = map.get(dest);\n                    map.delete(dest);\n                    lostPiece = dest;\n                }\n                blackAliveSoldiers.delete(src);\n                blackAliveSoldiers.add(dest);\n                map.set(dest, map.get(src));\n                map.delete(src);\n                score = minimax(map, whiteAliveSoldiers, blackAliveSoldiers, whiteFallenSoldiers, blackFallenSoldiers, depth - 1, 1, alpha, beta, squares);\n                // Undo the previous move (better to undo than make copies of arrays, undo is better big-O)\n                map.set(src, map.get(dest));\n                map.delete(dest);\n                blackAliveSoldiers.delete(dest);\n                blackAliveSoldiers.add(src);\n                if (lostPiece !== undefined) {\n                    whiteAliveSoldiers.add(lostPiece);\n                    whiteFallenSoldiers.pop();\n                    map.set(dest, lostPieceObj);\n                }\n                if (score < bestMove) {\n                    bestMove = score;\n                }\n\n                beta = Math.min(beta, bestMove);\n                if (beta <= alpha) {\n                    break outerMinimizingLoop;\n                }\n            }\n        }\n    }\n    return bestMove;\n}\n\n/**\n * Calculate the current score of the board, with white being positive and black being negative\n * @param {ap<Number, Piece>} map - The Map representing the pieces on the board\n * @param {Set<Number>} whiteAliveSoldiers - The indices of the alive white pieces on the board\n * @param {Set<Number>} blackAliveSoldiers - The indices of the alive black pieces on the board\n */\nfunction evaluateScore(map, whiteAliveSoldiers, blackAliveSoldiers) {\n    var sum = 0;\n    //console.log(map);\n    whiteAliveSoldiers.forEach(element => {\n        sum += map.get(element).getValue();\n    });\n    blackAliveSoldiers.forEach(element => {\n        sum -= map.get(element).getValue();\n    });\n    return sum;\n}\n\n/**\n * Swaps two keys in a map, even if the mapping is undefined\n * @param {Map<Number, Piece>} map - The Map of which the keys should be swapped\n * @param {*} a - The first key of the value to be swapped\n * @param {*} b - The second key of the value to be swapped\n */\nfunction swapInMap(map, a, b) {\n    //console.log(map instanceof Map);\n    var itemAtA = map.get(a);\n    var itemAtB = map.get(b);\n    map.delete(a);\n    map.delete(b);\n    if (itemAtA !== undefined) {\n        map.set(b, itemAtA);\n    }\n    if (itemAtB !== undefined) {\n        map.set(a, itemAtB);\n    }\n}\n\n","import React from 'react';\nimport { GrReactjs, GrHeroku, GrGithub } from 'react-icons/gr';\n\n\nimport '../index.css';\nimport Board from './board.js';\nimport King from '../pieces/king'\nimport FallenSoldierBlock from './fallen-soldier-block.js';\nimport { initialiseChessBoard, getInitialSoldierIndices } from '../helpers/board-initialiser.js';\nimport minimaxRunner from '../helpers/minimax';\n\nexport default class Game extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      squares: initialiseChessBoard(),\n      isPossibleMove: Array(64).fill(false),\n      whiteFallenSoldiers: [],\n      blackFallenSoldiers: [],\n      whiteAliveSoldiers: getInitialSoldierIndices(1),\n      blackAliveSoldiers: getInitialSoldierIndices(2),\n      player: 1,\n      sourceSelection: -1,\n      status: 'Your turn! To get started, click a white chess piece and click again on a highlighted square to place it there. If there are no highlighted squares, it means the piece you picked has no valid moves, so try another piece!',\n      turn: 'white',\n      score: '0',\n      bestSrc: 'N/A',\n      bestDest: 'N/A',\n      computations: 'N/A',\n      depth: 4,\n      isGameOver: false\n    }\n  }\n\n  /**\n   * Runs Chess Logic when Player clicks the board\n   * @param {Number} i - The location on the board that the user selected\n   */\n  handleClick(i) {\n    if (this.state.isGameOver) {\n      return;\n    }\n    console.log(this.state);\n    const squares = [...this.state.squares];\n    if (this.state.sourceSelection === -1) { // If no piece is already selected (i.e. first click)\n      if (!squares[i] || squares[i].player !== this.state.player) { // If player selected null piece or a piece that isn't under control of player\n        this.setState({ status: \"Wrong selection. Choose player \" + this.state.player + \" pieces.\" });\n        if (squares[i]) {\n          squares[i].style = { ...squares[i].style, backgroundColor: \"\" };\n        }\n      }\n      else {\n        // Player clicked a piece to move\n        squares[i].style = { ...squares[i].style, backgroundColor: \"#856312\" };\n        squares[i].getPossibleMoves(i, squares).forEach((value) => {\n          this.state.isPossibleMove[value] = true;\n        });\n        this.setState({\n          status: \"Choose destination for the selected piece\",\n          sourceSelection: i\n        })\n      }\n      return\n    }\n\n    // remove background color\n    squares[this.state.sourceSelection].style = { ...squares[this.state.sourceSelection].style, backgroundColor: \"\" };\n    squares[this.state.sourceSelection].getPossibleMoves(this.state.sourceSelection, squares).forEach((value) => {\n      this.state.isPossibleMove[value] = false;\n    });\n\n    // Prevent moving piece on top of another piece of the same color\n    if (squares[i] && squares[i].player === this.state.player) {\n      this.setState({\n        status: \"Wrong selection. Choose valid source and destination again.\",\n        sourceSelection: -1,\n      });\n    }\n    else {\n      const whiteFallenSoldiers = [];\n      const blackFallenSoldiers = [];\n      const whiteAliveSoldiers = this.state.whiteAliveSoldiers;\n      const blackAliveSoldiers = this.state.blackAliveSoldiers;\n\n      const isMovePossible = squares[this.state.sourceSelection].isMovePossible(this.state.sourceSelection, i, squares);\n      if (isMovePossible) {\n        if (squares[i] !== null) { // If piece kills an opponent's piece\n          if (squares[i].player === 1) {\n            whiteFallenSoldiers.push(squares[i]);\n            // Remove dead piece from aliveSoldiers array\n            whiteAliveSoldiers.delete(i);\n          }\n          else {\n            blackFallenSoldiers.push(squares[i]);\n            // Remove dead piece from aliveSoldiers array\n            blackAliveSoldiers.delete(i);\n          }\n\n          // Game over if the piece that died is a King\n          if (squares[i] instanceof King) {\n            console.log(\"Game over\");\n            squares[i] = squares[this.state.sourceSelection];\n            squares[this.state.sourceSelection] = null;\n            this.setState(oldState => ({\n              sourceSelection: -1,\n              squares,\n              whiteFallenSoldiers: [...oldState.whiteFallenSoldiers, ...whiteFallenSoldiers],\n              blackFallenSoldiers: [...oldState.blackFallenSoldiers, ...blackFallenSoldiers],\n              status: this.state.turn.charAt(0).toUpperCase() + this.state.turn.slice(1) + \" wins! Game Over!\", // Capitalize the player name\n              isGameOver: true\n            }));\n          }\n        }\n\n        squares[i] = squares[this.state.sourceSelection];\n        squares[this.state.sourceSelection] = null;\n        // remove sourceSelection add I (i.e. update aliveSoldiers arrays)\n        if (this.state.player === 1) { // White\n          whiteAliveSoldiers.delete(this.state.sourceSelection);\n          whiteAliveSoldiers.add(i);\n        }\n        else if (this.state.player === 2) { // Black\n          blackAliveSoldiers.delete(this.state.sourceSelection);\n          blackAliveSoldiers.add(i);\n        }\n        if (!this.state.isGameOver) {\n          // Update turn\n          let player = this.state.player === 1 ? 2 : 1;\n          let turn = this.state.turn === 'white' ? 'black' : 'white';\n          this.setState(oldState => ({\n            sourceSelection: -1,\n            squares,\n            whiteFallenSoldiers: [...oldState.whiteFallenSoldiers, ...whiteFallenSoldiers],\n            blackFallenSoldiers: [...oldState.blackFallenSoldiers, ...blackFallenSoldiers],\n            whiteAliveSoldiers: whiteAliveSoldiers,\n            blackAliveSoldiers: blackAliveSoldiers,\n            player,\n            status: '',\n            turn\n          }));\n\n          // Call minimax for opponent\n          /*if (player === 1) {\n            setTimeout(minimaxRunner, 1000, squares,\n              this.state.whiteAliveSoldiers, this.state.blackAliveSoldiers,\n              this.state.whiteFallenSoldiers, this.state.blackFallenSoldiers,\n              this.state.depth, 1, this);\n          }\n          else {\n            setTimeout(minimaxRunner, 1000, squares,\n              this.state.whiteAliveSoldiers, this.state.blackAliveSoldiers,\n              this.state.whiteFallenSoldiers, this.state.blackFallenSoldiers,\n              this.state.depth, 2, this);\n          }*/\n          if (player === 2) {\n            setTimeout(minimaxRunner, 1000, squares,\n              this.state.whiteAliveSoldiers, this.state.blackAliveSoldiers,\n              this.state.whiteFallenSoldiers, this.state.blackFallenSoldiers,\n              this.state.depth, 2, this);\n          }\n        }\n      }\n      else {\n        this.setState({\n          status: \"Wrong selection. Choose valid source and destination again- impossible move.\",\n          sourceSelection: -1,\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the index of the king (i.e. the king's location)\n   * @param {Piece[]} squares - The array representing the current state of the board\n   * @param {Number} player - The player ID of the King requested\n   */\n  getKingPosition(squares, player) {\n    return squares.reduce((acc, curr, i) =>\n      acc || //King may be only one, if we had found it, returned his position\n      ((curr //current squre mustn't be a null\n        && (curr.getPlayer() === player)) //we are looking for aspecial king \n        && (curr instanceof King)\n        && i), // returned position if all conditions are completed\n      null)\n  }\n\n  /**\n   * Returns true if player is Check, and false if not check.\n   * @param {Piece[]} squares - The array representing the current state of the board\n   * @param {Number} player - The player ID requested to check\n   */\n  isCheckForPlayer(squares, player) {\n    const opponent = player === 1 ? 2 : 1\n    const playersKingPosition = this.getKingPosition(squares, player)\n    const canPieceKillPlayersKing = (piece, i) => piece.isMovePossible(playersKingPosition, i, squares)\n    return squares.reduce((acc, curr, idx) =>\n      acc ||\n      (curr &&\n        (curr.getPlayer() === opponent) && canPieceKillPlayersKing(curr, idx)\n        && true),\n      false)\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"game\">\n          <div className=\"game-board\">\n            <Board\n              squares={this.state.squares}\n              onClick={(i) => this.handleClick(i)}\n              isPossibleMove={this.state.isPossibleMove}\n            />\n          </div>\n          <div className=\"game-info\">\n            <div className=\"game-bottom-box\">\n              <div className=\"float-child\">\n                <h3 className=\"turn-label\">Turn</h3>\n                <div id=\"player-turn-box\" style={{ backgroundColor: this.state.turn }}>\n                </div>\n              </div>\n\n              <div className=\"float-child console-text\">\n                <p>\n                  Best Starting Position: {this.state.bestSrc}\n                  <br></br>\n                  Best Ending Position: {this.state.bestDest}\n                  <br></br>\n                  Computations Performed: {this.state.computations}\n                  <br></br>\n                  Recursive Depth: {this.state.depth}\n                </p>\n              </div>\n            </div>\n            <div className=\"game-status\">{this.state.status}</div>\n\n            <div className=\"fallen-soldier-block\">\n\n              {<FallenSoldierBlock\n                whiteFallenSoldiers={this.state.whiteFallenSoldiers}\n                blackFallenSoldiers={this.state.blackFallenSoldiers}\n              />\n              }\n            </div>\n\n          </div>\n        </div>\n\n        <div className=\"icons-attribution\">\n          <div>\n            <div className=\"tech-used\">\n              <p>\n                Created by Jonathan Xu using <span className=\"react-icon\"><GrReactjs /> React</span> and deployed to <span className=\"heroku-icon\"><GrHeroku /> Heroku</span>.\n              </p>\n              <p>\n                <a href=\"https://github.com/ViciousCupcake/Chess-AI\" target=\"_blank\" rel=\"noreferrer\"> <GrGithub /> Source Code</a>\n              </p>\n            </div>\n            <div>\n              <small> Chess Icons And Favicon (extracted) By <a href=\"https://en.wikipedia.org/wiki/User:Cburnett\" >en:User:Cburnett</a> [\n              <a href=\"http://www.gnu.org/copyleft/fdl.html\" target=\"_blank\" rel=\"noreferrer\">GFDL</a>, <a href=\"http://creativecommons.org/licenses/by-sa/3.0/\" target=\"_blank\" rel=\"noreferrer\">CC-BY-SA-3.0</a>,\n              <a href=\"http://opensource.org/licenses/bsd-license.php\" target=\"_blank\" rel=\"noreferrer\">BSD</a> or <a href=\"http://www.gnu.org/licenses/gpl.html\" target=\"_blank\" rel=\"noreferrer\">GPL</a>],\n              <span> </span><a href=\"https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\" target=\"_blank\" rel=\"noreferrer\">via Wikimedia Commons</a>.</small>\n            </div>\n            <div>\n              <small> Chess Board Created by <a href=\"https://www.techighness.com\" target=\"_blank\" rel=\"noreferrer\">Talha Awan</a> [<a href=\"https://mit-license.org\" target=\"_blank\" rel=\"noreferrer\">MIT License</a>]</small>\n            </div>\n          </div>\n        </div>\n      </div>\n\n\n    );\n  }\n}\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport Game from './components/game.js'\n\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);"],"sourceRoot":""}